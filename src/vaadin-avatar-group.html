<!--
@license
Copyright (c) 2020 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../polymer/lib/utils/async.html">
<link rel="import" href="../../polymer/lib/utils/debounce.html">
<link rel="import" href="../../iron-a11y-announcer/iron-a11y-announcer.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../iron-a11y-announcer/iron-a11y-announcer.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<link rel="import" href="../../vaadin-item/vaadin-item.html">
<link rel="import" href="vaadin-avatar-group-list-box.html">
<link rel="import" href="vaadin-avatar-group-overlay.html">
<link rel="import" href="vaadin-avatar.html">

<dom-module id="vaadin-avatar-group">
  <template>
    <style>
      :host {
        display: block;
        width: 100%; /* prevent collapsing inside non-stretching column flex */
        --vaadin-avatar-group-overlap: 8px;
        --vaadin-avatar-group-overlap-border: 2px;
        --vaadin-avatar-size: 64px;
      }

      [part="container"] {
        display: flex;
        position: relative;
        width: 100%;
        flex-wrap: nowrap;
      }

      [part="avatar"] {
        flex-shrink: 0;
      }

      [part="avatar"]:not(:first-child) {
        -webkit-mask-image: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzAwIDMwMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwMCAwSDBWMzAwSDMwMFYwWk0xNTAgMjAwQzE3Ny42MTQgMjAwIDIwMCAxNzcuNjE0IDIwMCAxNTBDMjAwIDEyMi4zODYgMTc3LjYxNCAxMDAgMTUwIDEwMEMxMjIuMzg2IDEwMCAxMDAgMTIyLjM4NiAxMDAgMTUwQzEwMCAxNzcuNjE0IDEyMi4zODYgMjAwIDE1MCAyMDBaIiBmaWxsPSJibGFjayIvPjwvc3ZnPg==);
        mask-image: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzAwIDMwMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwMCAwSDBWMzAwSDMwMFYwWk0xNTAgMjAwQzE3Ny42MTQgMjAwIDIwMCAxNzcuNjE0IDIwMCAxNTBDMjAwIDEyMi4zODYgMTc3LjYxNCAxMDAgMTUwIDEwMEMxMjIuMzg2IDEwMCAxMDAgMTIyLjM4NiAxMDAgMTUwQzEwMCAxNzcuNjE0IDEyMi4zODYgMjAwIDE1MCAyMDBaIiBmaWxsPSJibGFjayIvPjwvc3ZnPg==);
        -webkit-mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
        mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
      }

      [part="avatar"]:not([dir="rtl"]):not(:first-child) {
        margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
        -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
        mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
      }

      [part="avatar"][dir="rtl"]:not(:first-child) {
        margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
        -webkit-mask-position: calc(50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width));
        mask-position: calc(50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width));
      }
    </style>
    <div id="container" part="container">
      <template id="items" is="dom-repeat" items="[[__computeItems(items.*, __itemsInView, maxItemsVisible)]]">
        <vaadin-avatar
          name="[[item.name]]"
          abbr="[[item.abbr]]"
          img="[[item.img]]"
          part="avatar"
          theme$="[[theme]]"
          i18n="[[i18n]]"
          color-index="[[item.colorIndex]]"
        ></vaadin-avatar>
      </template>
      <vaadin-avatar
        id="overflow"
        part="avatar"
        hidden$="[[__computeMoreHidden(items.length, __itemsInView, __maxReached)]]"
        abbr="[[__computeMore(items.length, __itemsInView, maxItemsVisible)]]"
        theme$="[[theme]]"
        on-click="_onOverflowClick"
        on-keydown="_onOverflowKeyDown"
        aria-haspopup="listbox"
      ></vaadin-avatar>
    </div>
    <vaadin-avatar-group-overlay id="overlay" opened="{{_opened}}" on-vaadin-overlay-close="_onVaadinOverlayClose">
      <template>
        <vaadin-avatar-group-list-box on-keydown="_onListKeyDown">
          <template is="dom-repeat" items="[[__computeExtraItems(items.*, __itemsInView, maxItemsVisible)]]">
            <vaadin-item theme="avatar-group-item" role="option">
              <vaadin-avatar
                name="[[item.name]]"
                abbr="[[item.abbr]]"
                img="[[item.img]]"
                i18n="[[i18n]]"
                part="avatar"
                theme$="[[theme]]"
                color-index="[[item.colorIndex]]"
                tabindex="-1"
                aria-hidden="true"
              ></vaadin-avatar>
              [[item.name]]
            </vaadin-item>
          </template>
        </vaadin-avatar-group-list-box>
      </template>
    </vaadin-avatar-group-overlay>
  </template>
  <script>
    (function() {


      /**
       * `<vaadin-avatar-group>` is a Web Component providing avatar group displaying functionality.
       *
       * ```html
       *   <vaadin-avatar-group>
       *     <vaadin-avatar abbr="YY"></vaadin-avatar>
       *     <vaadin-avatar abbr="SK"></vaadin-avatar>
       *     <vaadin-avatar abbr="JJ"></vaadin-avatar>
       *   </vaadin-avatar-group>
       * ```
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class AvatarGroupElement extends
        Vaadin.ElementMixin(
          Vaadin.ThemableMixin(
            Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element))) {

        static get is() {
          return 'vaadin-avatar-group';
        }

        static get version() {
          return '1.0.0-alpha8';
        }

        static get properties() {
          return {
            /**
             * An array containing the items which will be stamped as avatars
             * @type {!Array<!AvatarGroupItem> | undefined}
             */
            items: {
              type: Array
            },

            /**
             * The maximum number of avatars to display. By default, all the avatars are displayed.
             * When maxItemsVisible is set, the overflowing avatars are grouped into one avatar with a dropdown.
             * Setting 0 or 1 has no effect so there are always at least two avatars visible.
             */
            maxItemsVisible: {
              type: Number
            },

            /**
             * The object used to localize this component.
             * To change the default localization, replace the entire
             * _i18n_ object or just the property you want to modify.
             *
             * The object has the following JSON structure and default values:
             * ```
             * {
             *   // Translation of the anonymous user avatar title.
             *   anonymous: 'anonymous',
             *   // Translation of the avatar group accessible label.
             *   // {count} is replaced with the actual count of users.
             *   activeUsers: {
             *     one: 'Currently one active user',
             *     many: 'Currently {count} active users'
             *   },
             *   // Screen reader announcement when user joins group.
             *   // {user} is replaced with the name or abbreviation.
             *   // When neither is set, "anonymous" is used instead.
             *   joined: '{user} joined',
             *   // Screen reader announcement when user leaves group.
             *   // {user} is replaced with the name or abbreviation.
             *   // When neither is set, "anonymous" is used instead.
             *   left: '{user} left'
             * }
             * ```
             * @type {!AvatarGroupI18n}
             * @default {English/US}
             */
            i18n: {
              type: Object,
              value: () => {
                return {
                  anonymous: 'anonymous',
                  activeUsers: {
                    one: 'Currently one active user',
                    many: 'Currently {count} active users'
                  },
                  joined: '{user} joined',
                  left: '{user} left'
                };
              }
            },

            /** @private */
            __maxReached: {
              type: Boolean,
              computed: '__computeMaxReached(items.length, maxItemsVisible)'
            },

            /** @private */
            __itemsInView: {
              type: Number,
              value: null
            },

            /** @private */
            _opened: {
              type: Boolean,
              observer: '__openedChanged',
              value: false
            }
          };
        }

        static get observers() {
          return [
            '__computeMoreTitle(items.length, __itemsInView, maxItemsVisible)',
            '__itemsChanged(items.splices, items.*)',
            '__i18nItemsChanged(i18n.*, items.length)'
          ];
        }

        /** @protected */
        ready() {
          super.ready();

          Polymer.IronA11yAnnouncer.requestAvailability();

          this.__boundSetPosition = this.__setPosition.bind(this);

          this.addEventListener('iron-resize', this._onResize.bind(this));

          this._overlayElement = this.shadowRoot.querySelector('vaadin-avatar-group-overlay');

          Polymer.RenderStatus.afterNextRender(this, () => {
            this.__setItemsInView();
          });
        }

        /**
         * @param {string} name
         * @param {?string} oldValue
         * @param {?string} newValue
         * @protected
         */
        attributeChangedCallback(name, oldValue, newValue) {
          super.attributeChangedCallback(name, oldValue, newValue);
          if (name === 'dir') {
            this.__setPosition();
          }
        }

        /**
         * @return {!Array<!HTMLElement>}
         * @protected
         */
        get _avatars() {
          return this.shadowRoot.querySelectorAll('vaadin-avatar');
        }

        /** @private */
        __announce(text) {
          this.dispatchEvent(
            new CustomEvent('iron-announce', {
              bubbles: true,
              composed: true,
              detail: {
                text
              }
            })
          );
        }

        /** @private */
        __getMessage(user, action) {
          return action.replace('{user}', user.name || user.abbr || this.i18n.anonymous);
        }

        /** @private */
        _onOverflowClick(e) {
          e.stopPropagation();
          if (this._opened) {
            this.$.overlay.close();
          } else if (!e.defaultPrevented) {
            this._opened = true;
          }
        }

        /** @private */
        _onOverflowKeyDown(e) {
          if (!this._opened) {
            if (/^(Enter|SpaceBar|\s)$/.test(e.key)) {
              e.preventDefault();
              this._opened = true;
            }
          }
        }

        /** @private */
        _onListKeyDown(event) {
          if (event.key === 'Escape' || event.key === 'Esc' || /^(Tab)$/.test(event.key)) {
            this._opened = false;
          }
        }

        /** @private */
        _onResize() {
          this.__debounceResize = Polymer.Debouncer.debounce(
            this.__debounceResize,
            Polymer.Async.timeOut.after(0),
            () => {
              this.__setItemsInView();
              this.__setPosition();
            }
          );
        }

        /** @private */
        _onVaadinOverlayClose(e) {
          if (e.detail.sourceEvent && e.detail.sourceEvent.composedPath().indexOf(this) !== -1) {
            e.preventDefault();
          }
        }

        /** @private */
        __computeItems(arr, itemsInView, maxItemsVisible) {
          const items = arr.base || [];
          const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
          return limit ? items.slice(0, limit) : items;
        }

        /** @private */
        __computeExtraItems(arr, itemsInView, maxItemsVisible) {
          const items = arr.base || [];
          const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
          return limit ? items.slice(limit) : items;
        }

        /** @private */
        __computeMaxReached(items, maxItemsVisible) {
          return maxItemsVisible != null && items > this.__getMax(maxItemsVisible);
        }

        /** @private */
        __computeMore(items, itemsInView, maxItemsVisible) {
          return maxItemsVisible != null ? `+${items - this.__getMax(maxItemsVisible) + 1}` : `+${items - itemsInView}`;
        }

        /** @private */
        __computeMoreHidden(items, itemsInView, maxReached) {
          return !maxReached && !(itemsInView && itemsInView < items);
        }

        /** @private */
        __computeMoreTitle(items, itemsInView, maxItemsVisible) {
          const limit = this.__getLimit(items, itemsInView, maxItemsVisible);
          if (limit == null) {
            return;
          }
          const result = [];
          for (let i = limit; i < items; i++) {
            const item = this.items[i];
            result.push(item.name || item.abbr || 'anonymous');
          }
          // override generated title attribute
          this.$.overflow.setAttribute('title', result.join('\n'));
        }

        /** @private */
        __getLimit(items, itemsInView, maxItemsVisible) {
          let limit = null;
          // handle max set to 0 or 1
          const adjustedMax = this.__getMax(maxItemsVisible);
          if (maxItemsVisible != null && adjustedMax < items) {
            limit = adjustedMax - 1;
          } else if (itemsInView && itemsInView < items) {
            limit = itemsInView;
          }
          return limit;
        }

        /** @private */
        __getMax(maxItemsVisible) {
          return Math.max(maxItemsVisible, 2);
        }

        /** @private */
        __itemsChanged(splices, itemsChange) {
          const items = itemsChange.base;
          this.$.items.render();
          this.__setItemsInView();

          // mutation using group.splice('items')
          if (splices && Array.isArray(splices.indexSplices)) {
            splices.indexSplices.forEach((mutation) => {
              this.__announceItemsChange(items, mutation);
            });
          } else if (Array.isArray(items) && Array.isArray(this.__oldItems)) {
            // mutation using group.set('items')
            const diff = Polymer.ArraySplice.calculateSplices(items, this.__oldItems);
            diff.forEach((mutation) => {
              this.__announceItemsChange(items, mutation);
            });
          }

          this.__oldItems = items;
        }

        /** @private */
        __announceItemsChange(items, mutation) {
          const {addedCount, index, removed} = mutation;
          let addedMsg = [];
          let removedMsg = [];
          if (addedCount) {
            addedMsg = items
              .slice(index, index + addedCount)
              .map((user) => this.__getMessage(user, this.i18n.joined || '{user} joined'));
          }

          if (removed) {
            removedMsg = removed.map((user) => this.__getMessage(user, this.i18n.left || '{user} left'));
          }

          const messages = removedMsg.concat(addedMsg);
          if (messages.length > 0) {
            this.__announce(messages.join(', '));
          }
        }

        /** @private */
        __i18nItemsChanged(i18n, items) {
          const {base} = i18n;
          if (base && base.activeUsers) {
            const field = items === 1 ? 'one' : 'many';
            if (base.activeUsers[field]) {
              this.setAttribute('aria-label', base.activeUsers[field].replace('{count}', items || 0));
            }
          }
        }

        /** @private */
        __openedChanged(opened, wasOpened) {
          if (opened) {
            if (!this._menuElement) {
              this._menuElement = this._overlayElement.content.querySelector('vaadin-avatar-group-list-box');
              this._menuElement.setAttribute('role', 'listbox');
            }

            this._openedWithFocusRing = this.$.overflow.hasAttribute('focus-ring');

            const avatars = this._menuElement.querySelectorAll('vaadin-avatar');
            avatars.forEach(avatar => avatar.removeAttribute('title'));

            this._menuElement.focus();
            this.__setPosition();
            window.addEventListener('scroll', this.__boundSetPosition, true);
          } else if (wasOpened) {
            this.$.overflow.focus();
            if (this._openedWithFocusRing) {
              this.$.overflow.setAttribute('focus-ring', '');
            }
            window.removeEventListener('scroll', this.__boundSetPosition, true);
          }
          this.$.overflow.setAttribute('aria-expanded', opened === true);
        }

        /** @private */
        __setItemsInView() {
          const avatars = this._avatars;
          const items = this.items;

          // always show at least two avatars
          if (!items || !avatars || avatars.length < 3) {
            return;
          }

          // assume all the avatars have the same width
          const avatarWidth = avatars[0].clientWidth;

          // take negative margin into account
          const {marginLeft, marginRight} = getComputedStyle(avatars[1]);

          const offset = this.getAttribute('dir') == 'rtl' ?
            parseInt(marginRight, 0) - parseInt(marginLeft, 0) :
            parseInt(marginLeft, 0) - parseInt(marginRight, 0);

          let result = Math.floor((this.$.container.offsetWidth - avatarWidth) / (avatarWidth + offset));

          // only show overlay if two or more avatars don't fit
          if (result === items.length - 1) {
            result = items.length;
          }

          // close overlay if all avatars become visible
          if (result >= items.length && this._opened) {
            this.$.overlay.close();
            // FIXME: hack to avoid jump before closing
            this.$.overlay._flushAnimation('closing');
          }

          // reserve space for overflow avatar
          this.__itemsInView = result;
        }

        /** @private */
        __setPosition() {
          if (!this._opened) {
            return;
          }
          const btnRect = this.$.overflow.getBoundingClientRect();
          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
          const bottomAlign = btnRect.top > (viewportHeight - btnRect.height) / 2;

          const isRtl = this.getAttribute('dir') === 'rtl';

          if (isRtl) {
            this._overlayElement.style.right = document.documentElement.clientWidth - btnRect.right + 'px';
          } else {
            this._overlayElement.style.left = btnRect.left + 'px';
          }

          if (bottomAlign) {
            this._overlayElement.setAttribute('bottom-aligned', '');
            this._overlayElement.style.removeProperty('top');
            this._overlayElement.style.bottom = (viewportHeight - btnRect.top) + 'px';
          } else {
            this._overlayElement.removeAttribute('bottom-aligned');
            this._overlayElement.style.removeProperty('bottom');
            this._overlayElement.style.top = btnRect.bottom + 'px';
          }
        }
      }

      customElements.define(AvatarGroupElement.is, AvatarGroupElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.AvatarGroupElement = AvatarGroupElement;
    })();
  </script>
</dom-module>
