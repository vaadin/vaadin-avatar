<!--
@license
Copyright (c) 2020 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<link rel="import" href="../../vaadin-item/vaadin-item.html">
<link rel="import" href="vaadin-avatar-group-list-box.html">
<link rel="import" href="vaadin-avatar-group-overlay.html">
<link rel="import" href="vaadin-avatar.html">

<dom-module id="vaadin-avatar-group">
  <template>
    <style>
      :host {
        display: flex;
        align-items: center;
      }

      [part="avatar"] {
        border: calc(var(--_avatar-group-offset) / 20) solid white;
      }

      #container vaadin-avatar:not(:first-child) {
        /* Should take scalability of the host into account */
        margin-left: calc(var(--_avatar-group-offset) / -3);
        -webkit-mask-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CgogPGc+CiAgPHRpdGxlPmJhY2tncm91bmQ8L3RpdGxlPgogIDxyZWN0IGZpbGw9Im5vbmUiIGlkPSJjYW52YXNfYmFja2dyb3VuZCIgaGVpZ2h0PSI0MDIiIHdpZHRoPSI1ODIiIHk9Ii0xIiB4PSItMSIvPgogPC9nPgogPGc+CiAgPHRpdGxlPkxheWVyIDE8L3RpdGxlPgogIDxwYXRoIHRyYW5zZm9ybT0icm90YXRlKC0xODAgMTYsMTUuOTk5OTk5OTk5OTk5OTk4KSAiIGlkPSJzdmdfMSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMzQsLTAuOTc1NzdjLTYuOTkxMTUsMi40NzEwMiAtMTIsOS4xMzg0NiAtMTIsMTYuOTc1NzdjMCw3LjgzNzMxIDUuMDA4ODUsMTQuNTA0NzUgMTIsMTYuOTc1NzdsMCwxLjAyNDIzbC0zNiwwbDAsLTM2bDM2LDBsMCwxLjAyNDIzeiIvPgogPC9nPgo8L3N2Zz4=);
        mask-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CgogPGc+CiAgPHRpdGxlPmJhY2tncm91bmQ8L3RpdGxlPgogIDxyZWN0IGZpbGw9Im5vbmUiIGlkPSJjYW52YXNfYmFja2dyb3VuZCIgaGVpZ2h0PSI0MDIiIHdpZHRoPSI1ODIiIHk9Ii0xIiB4PSItMSIvPgogPC9nPgogPGc+CiAgPHRpdGxlPkxheWVyIDE8L3RpdGxlPgogIDxwYXRoIHRyYW5zZm9ybT0icm90YXRlKC0xODAgMTYsMTUuOTk5OTk5OTk5OTk5OTk4KSAiIGlkPSJzdmdfMSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMzQsLTAuOTc1NzdjLTYuOTkxMTUsMi40NzEwMiAtMTIsOS4xMzg0NiAtMTIsMTYuOTc1NzdjMCw3LjgzNzMxIDUuMDA4ODUsMTQuNTA0NzUgMTIsMTYuOTc1NzdsMCwxLjAyNDIzbC0zNiwwbDAsLTM2bDM2LDBsMCwxLjAyNDIzeiIvPgogPC9nPgo8L3N2Zz4=);
        -webkit-mask-size: 100% 100%;
        mask-size: 100% 100%;
        flex: none;
      }
    </style>
    <div id="container">
      <template is="dom-repeat" items="[[__computeItems(items.*, max)]]">
        <vaadin-avatar
          name="[[item.name]]"
          abbr="[[item.abbr]]"
          img="[[item.img]]"
          part="avatar"
          theme$="[[theme]]"
          tabindex="0"
          on-focusin="_onFocusIn"
          on-focusout="_onFocusOut"
        ></vaadin-avatar>
      </template>
      <vaadin-avatar
        id="overflow"
        part="avatar"
        hidden$="[[!_maxReached]]"
        abbr="[[__computeMore(items.length, max)]]"
        theme$="[[theme]]"
        tabindex="0"
        on-focusin="_onFocusIn"
        on-focusout="_onFocusOut"
        on-click="_onOverflowClick"
        on-keydown="_onOverflowKeyDown"
      ></vaadin-avatar>
    </div>
    <vaadin-avatar-group-overlay id="overlay" opened="{{_opened}}" on-vaadin-overlay-close="_onVaadinOverlayClose">
      <template>
        <vaadin-avatar-group-list-box on-keydown="_onListKeyDown">
          <template is="dom-repeat" items="[[__computeExtraItems(items.*, max)]]">
            <vaadin-item theme="avatar-group-item">
              <vaadin-avatar
                name="[[item.name]]"
                abbr="[[item.abbr]]"
                img="[[item.img]]"
                part="avatar"
                theme$="[[theme]]"
              ></vaadin-avatar>
              [[item.name]]
            </vaadin-item>
          </template>
        </vaadin-avatar-group-list-box>
      </template>
    </vaadin-avatar-group-overlay>
  </template>
  <script>
    (function() {

      // We consider the keyboard to be active if the window has received a keydown
      // event since the last mousedown event.
      let keyboardActive = false;

      // Listen for top-level keydown and mousedown events.
      // Use capture phase so we detect events even if they're handled.
      window.addEventListener(
        'keydown',
        () => {
          keyboardActive = true;
        },
        true
      );

      window.addEventListener(
        'mousedown',
        () => {
          keyboardActive = false;
        },
        true
      );

      /**
       * `<vaadin-avatar-group>` is a Web Component providing avatar group displaying functionality.
       *
       * ```html
       *   <vaadin-avatar-group>
       *     <vaadin-avatar abbr="YY"></vaadin-avatar>
       *     <vaadin-avatar abbr="SK"></vaadin-avatar>
       *     <vaadin-avatar abbr="JJ"></vaadin-avatar>
       *   </vaadin-avatar-group>
       * ```
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class AvatarGroupElement extends
        Vaadin.ElementMixin(
          Vaadin.ThemableMixin(
            Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element))) {

        static get is() {
          return 'vaadin-avatar-group';
        }

        static get version() {
          return '1.0.0-alpha1';
        }

        static get properties() {
          return {
            /**
             * An array containing the items which will be stamped as avatars
             */
            items: {
              type: Array,
              observer: '__itemsChanged'
            },

            /**
             * The maximum number of avatars to display.
             * By default, all the avatars are displayed.
             * When max is set, the overflowing avatars are grouped into one avatar.
             */
            max: {
              type: Number
            },

            _maxReached: {
              type: Boolean,
              computed: '__computeMaxReached(items.length, max)'
            },

            _opened: {
              type: Boolean,
              observer: '__openedChanged',
              value: false
            }
          };
        }

        ready() {
          super.ready();

          this.__boundSetPosition = this.__setPosition.bind(this);

          this.addEventListener('iron-resize', this._onResize.bind(this));

          this._overlayElement = this.shadowRoot.querySelector('vaadin-avatar-group-overlay');
        }

        _onOverflowClick(e) {
          e.stopPropagation();
          if (this._opened) {
            this.$.overlay.close();
          } else if (!e.defaultPrevented) {
            this._opened = true;
          }
        }

        _onOverflowKeyDown(e) {
          if (!this._opened) {
            if (/^(Enter|SpaceBar|\s)$/.test(e.key)) {
              e.preventDefault();
              this._opened = true;
            }
          }
        }

        _onFocusIn(event) {
          this._setFocused(event.composedPath()[0], true);
        }

        _onFocusOut(event) {
          this._setFocused(event.composedPath()[0], false);
        }

        _setFocused(target, focused) {
          if (focused) {
            target.setAttribute('focused', '');

            if (keyboardActive) {
              target.setAttribute('focus-ring', '');
            }
          } else {
            target.removeAttribute('focused');
            target.removeAttribute('focus-ring');
          }
        }

        _onListKeyDown(event) {
          if (event.key === 'Escape' || event.key === 'Esc') {
            this._opened = false;
          }
        }

        _onResize() {
          this.__updateOffset();
          this.__setPosition();
        }

        _onVaadinOverlayClose(e) {
          if (e.detail.sourceEvent && e.detail.sourceEvent.composedPath().indexOf(this) !== -1) {
            e.preventDefault();
          }
        }

        __computeItems(arr, max) {
          const items = arr.base || [];
          return max != null ? items.slice(0, max) : items;
        }

        __computeExtraItems(arr, max) {
          const items = arr.base || [];
          return max != null ? items.slice(max) : items;
        }

        __computeMaxReached(items, max) {
          return max != null && items > max;
        }

        __computeMore(items, max) {
          return `+${items - max}`;
        }

        __itemsChanged(items) {
          this.__updateOffset();
        }

        __openedChanged(opened, wasOpened) {
          if (opened) {
            if (!this._menuElement) {
              this._menuElement = this._overlayElement.content.querySelector('vaadin-avatar-group-list-box');
            }

            this._menuElement.focus();
            this.__setPosition();
            window.addEventListener('scroll', this.__boundSetPosition, true);
          } else if (wasOpened) {
            // force focus-ring
            keyboardActive = true;
            this.$.overflow.focus();
            window.removeEventListener('scroll', this.__boundSetPosition, true);
          }
        }

        __setPosition() {
          if (!this._opened) {
            return;
          }
          const btnRect = this.$.overflow.getBoundingClientRect();
          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
          const bottomAlign = btnRect.top > (viewportHeight - btnRect.height) / 2;

          const isRtl = this.getAttribute('dir') === 'rtl';

          if (isRtl) {
            this._overlayElement.style.right = document.documentElement.clientWidth - btnRect.right + 'px';
          } else {
            this._overlayElement.style.left = btnRect.left + 'px';
          }

          if (bottomAlign) {
            this._overlayElement.setAttribute('bottom-aligned', '');
            this._overlayElement.style.removeProperty('top');
            this._overlayElement.style.bottom = (viewportHeight - btnRect.top) + 'px';
          } else {
            this._overlayElement.removeAttribute('bottom-aligned');
            this._overlayElement.style.removeProperty('bottom');
            this._overlayElement.style.top = btnRect.bottom + 'px';
          }
        }

        __updateOffset() {
          if (this.items && this.items.length > 0) {
            requestAnimationFrame(() => {
              const width = this.$.container.clientWidth;
              const itemsCount = this.items.length;

              this.updateStyles({'--_avatar-group-offset': width / itemsCount + 'px'});
            });
          }
        }
      }

      customElements.define(AvatarGroupElement.is, AvatarGroupElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.AvatarGroupElement = AvatarGroupElement;
    })();
  </script>
</dom-module>
