<!--
@license
Copyright (c) 2020 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<link rel="import" href="../../vaadin-item/vaadin-item.html">
<link rel="import" href="vaadin-avatar-group-list-box.html">
<link rel="import" href="vaadin-avatar-group-overlay.html">
<link rel="import" href="vaadin-avatar.html">

<dom-module id="vaadin-avatar-group">
  <template>
    <style>
      :host {
        display: flex;
        align-items: center;
        --vaadin-avatar-group-overlap: 8px;
        --vaadin-avatar-group-overlap-border: 2px;
        --vaadin-avatar-size: 64px;
      }

      [part="avatar"]:not(:first-child) {
        -webkit-mask-image: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzAwIDMwMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwMCAwSDBWMzAwSDMwMFYwWk0xNTAgMjAwQzE3Ny42MTQgMjAwIDIwMCAxNzcuNjE0IDIwMCAxNTBDMjAwIDEyMi4zODYgMTc3LjYxNCAxMDAgMTUwIDEwMEMxMjIuMzg2IDEwMCAxMDAgMTIyLjM4NiAxMDAgMTUwQzEwMCAxNzcuNjE0IDEyMi4zODYgMjAwIDE1MCAyMDBaIiBmaWxsPSJibGFjayIvPjwvc3ZnPg==);
        mask-image: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzAwIDMwMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwMCAwSDBWMzAwSDMwMFYwWk0xNTAgMjAwQzE3Ny42MTQgMjAwIDIwMCAxNzcuNjE0IDIwMCAxNTBDMjAwIDEyMi4zODYgMTc3LjYxNCAxMDAgMTUwIDEwMEMxMjIuMzg2IDEwMCAxMDAgMTIyLjM4NiAxMDAgMTUwQzEwMCAxNzcuNjE0IDEyMi4zODYgMjAwIDE1MCAyMDBaIiBmaWxsPSJibGFjayIvPjwvc3ZnPg==);
        -webkit-mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
        mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
      }

      [part="avatar"]:not([dir="rtl"]):not(:first-child) {
        margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
        -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
        mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
      }

      [part="avatar"][dir="rtl"]:not(:first-child) {
        margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
        -webkit-mask-position: calc(50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width));
        mask-position: calc(50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width));
      }
    </style>
    <div id="container">
      <template is="dom-repeat" items="[[__computeItems(items.*, max)]]">
        <vaadin-avatar
          name="[[item.name]]"
          abbr="[[item.abbr]]"
          img="[[item.img]]"
          part="avatar"
          theme$="[[theme]]"
          i18n="[[i18n]]"
          color-index="[[item.colorIndex]]"
        ></vaadin-avatar>
      </template>
      <vaadin-avatar
        id="overflow"
        part="avatar"
        hidden$="[[!__maxReached]]"
        abbr="[[__computeMore(items.length, max)]]"
        theme$="[[theme]]"
        on-click="_onOverflowClick"
        on-keydown="_onOverflowKeyDown"
        aria-haspopup="listbox"
      ></vaadin-avatar>
    </div>
    <vaadin-avatar-group-overlay id="overlay" opened="{{_opened}}" on-vaadin-overlay-close="_onVaadinOverlayClose">
      <template>
        <vaadin-avatar-group-list-box on-keydown="_onListKeyDown">
          <template is="dom-repeat" items="[[__computeExtraItems(items.*, max)]]">
            <vaadin-item theme="avatar-group-item" role="option">
              <vaadin-avatar
                name="[[item.name]]"
                abbr="[[item.abbr]]"
                img="[[item.img]]"
                i18n="[[i18n]]"
                part="avatar"
                theme$="[[theme]]"
                color-index="[[item.colorIndex]]"
                tabindex="-1"
                aria-hidden="true"
              ></vaadin-avatar>
              [[item.name]]
            </vaadin-item>
          </template>
        </vaadin-avatar-group-list-box>
      </template>
    </vaadin-avatar-group-overlay>
  </template>
  <script>
    (function() {


      /**
       * `<vaadin-avatar-group>` is a Web Component providing avatar group displaying functionality.
       *
       * ```html
       *   <vaadin-avatar-group>
       *     <vaadin-avatar abbr="YY"></vaadin-avatar>
       *     <vaadin-avatar abbr="SK"></vaadin-avatar>
       *     <vaadin-avatar abbr="JJ"></vaadin-avatar>
       *   </vaadin-avatar-group>
       * ```
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class AvatarGroupElement extends
        Vaadin.ElementMixin(
          Vaadin.ThemableMixin(
            Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element))) {

        static get is() {
          return 'vaadin-avatar-group';
        }

        static get version() {
          return '1.0.0-alpha6';
        }

        static get properties() {
          return {
            /**
             * An array containing the items which will be stamped as avatars
             * @type {!Array<!AvatarGroupItem> | undefined}
             */
            items: {
              type: Array
            },

            /**
             * The maximum number of avatars to display.
             * By default, all the avatars are displayed.
             * When max is set, the overflowing avatars are grouped into one avatar.
             */
            max: {
              type: Number
            },

            /**
             * The object used to localize this component.
             * To change the default localization, replace the entire
             * _i18n_ object or just the property you want to modify.
             *
             * The object has the following JSON structure and default values:
                {
                  // Translation of the anonymous user avatar title.
                  anonymous: 'anonymous',
                  // Translation of the avatar group accessible label.
                  activeUsers: {
                    one: 'Currently one active user',
                    many: 'Currently {count} active users'
                  }
                }
            * @type {!AvatarGroupI18n}
            * @default {English/US}
            */
            i18n: {
              type: Object,
              value: () => {
                return {
                  anonymous: 'anonymous',
                  activeUsers: {
                    one: 'Currently one active user',
                    many: 'Currently {count} active users'
                  }
                };
              }
            },

            /** @private */
            __maxReached: {
              type: Boolean,
              computed: '__computeMaxReached(items.length, max)'
            },

            /** @private */
            _opened: {
              type: Boolean,
              observer: '__openedChanged',
              value: false
            }
          };
        }

        static get observers() {
          return [
            '__computeMoreTitle(items.length, max)',
            '__i18nItemsChanged(i18n.*, items.length)'
          ];
        }

        /** @protected */
        ready() {
          super.ready();

          this.__boundSetPosition = this.__setPosition.bind(this);

          this.addEventListener('iron-resize', this._onResize.bind(this));

          this._overlayElement = this.shadowRoot.querySelector('vaadin-avatar-group-overlay');
        }

        /**
         * @param {string} name
         * @param {?string} oldValue
         * @param {?string} newValue
         * @protected
         */
        attributeChangedCallback(name, oldValue, newValue) {
          super.attributeChangedCallback(name, oldValue, newValue);
          if (name === 'dir') {
            this.__setPosition();
          }
        }

        /** @private */
        _onOverflowClick(e) {
          e.stopPropagation();
          if (this._opened) {
            this.$.overlay.close();
          } else if (!e.defaultPrevented) {
            this._opened = true;
          }
        }

        /** @private */
        _onOverflowKeyDown(e) {
          if (!this._opened) {
            if (/^(Enter|SpaceBar|\s)$/.test(e.key)) {
              e.preventDefault();
              this._opened = true;
            }
          }
        }

        /** @private */
        _onListKeyDown(event) {
          if (event.key === 'Escape' || event.key === 'Esc' || /^(Tab)$/.test(event.key)) {
            this._opened = false;
          }
        }

        /** @private */
        _onResize() {
          this.__setPosition();
        }

        /** @private */
        _onVaadinOverlayClose(e) {
          if (e.detail.sourceEvent && e.detail.sourceEvent.composedPath().indexOf(this) !== -1) {
            e.preventDefault();
          }
        }

        /** @private */
        __computeItems(arr, max) {
          const items = arr.base || [];
          return max != null ? items.slice(0, max) : items;
        }

        /** @private */
        __computeExtraItems(arr, max) {
          const items = arr.base || [];
          return max != null ? items.slice(max) : items;
        }

        /** @private */
        __computeMaxReached(items, max) {
          return max != null && items > max;
        }

        /** @private */
        __computeMore(items, max) {
          return `+${items - max}`;
        }

        /** @private */
        __computeMoreTitle(items, max) {
          if (max == null) {
            return;
          }
          const result = [];
          for (let i = max; i < items; i++) {
            const item = this.items[i];
            result.push(item.name || item.abbr || 'anonymous');
          }
          // override generated title attribute
          this.$.overflow.setAttribute('title', result.join('\n'));
        }

        /** @private */
        __i18nItemsChanged(i18n, items) {
          const {base} = i18n;
          if (base && base.activeUsers) {
            const field = items === 1 ? 'one' : 'many';
            if (base.activeUsers[field]) {
              this.setAttribute('aria-label', base.activeUsers[field].replace('{count}', items));
            }
          }
        }

        /** @private */
        __openedChanged(opened, wasOpened) {
          if (opened) {
            if (!this._menuElement) {
              this._menuElement = this._overlayElement.content.querySelector('vaadin-avatar-group-list-box');
              this._menuElement.setAttribute('role', 'listbox');
            }

            this._openedWithFocusRing = this.$.overflow.hasAttribute('focus-ring');

            const avatars = this._menuElement.querySelectorAll('vaadin-avatar');
            avatars.forEach(avatar => avatar.removeAttribute('title'));

            this._menuElement.focus();
            this.__setPosition();
            window.addEventListener('scroll', this.__boundSetPosition, true);
          } else if (wasOpened) {
            this.$.overflow.focus();
            if (this._openedWithFocusRing) {
              this.$.overflow.setAttribute('focus-ring', '');
            }
            window.removeEventListener('scroll', this.__boundSetPosition, true);
          }
          this.$.overflow.setAttribute('aria-expanded', opened === true);
        }

        /** @private */
        __setPosition() {
          if (!this._opened) {
            return;
          }
          const btnRect = this.$.overflow.getBoundingClientRect();
          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
          const bottomAlign = btnRect.top > (viewportHeight - btnRect.height) / 2;

          const isRtl = this.getAttribute('dir') === 'rtl';

          if (isRtl) {
            this._overlayElement.style.right = document.documentElement.clientWidth - btnRect.right + 'px';
          } else {
            this._overlayElement.style.left = btnRect.left + 'px';
          }

          if (bottomAlign) {
            this._overlayElement.setAttribute('bottom-aligned', '');
            this._overlayElement.style.removeProperty('top');
            this._overlayElement.style.bottom = (viewportHeight - btnRect.top) + 'px';
          } else {
            this._overlayElement.removeAttribute('bottom-aligned');
            this._overlayElement.style.removeProperty('bottom');
            this._overlayElement.style.top = btnRect.bottom + 'px';
          }
        }
      }

      customElements.define(AvatarGroupElement.is, AvatarGroupElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.AvatarGroupElement = AvatarGroupElement;
    })();
  </script>
</dom-module>
