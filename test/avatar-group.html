<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-avatar-group tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="../vaadin-avatar-group.html">
</head>

<body>
  <test-fixture id="group">
    <template>
      <vaadin-avatar-group></vaadin-avatar-group>
    </template>
  </test-fixture>

  <script>
    function nextRender(target) {
      return new Promise(resolve => {
        Polymer.RenderStatus.afterNextRender(target, () => {
          resolve();
        });
      });
    }

    describe('avatar-group', () => {
      let group;

      beforeEach(function() {
        group = fixture('group');
      });

      describe('custom element definition', () => {
        it('should be defined with correct tag name', () => {
          expect(customElements.get('vaadin-avatar-group')).to.be.ok;
        });

        it('should not expose class name globally', () => {
          expect(window.AvatarGroupElement).not.to.be.ok;
        });

        it('should have a valid version number', () => {
          expect(group.constructor.version).to.match(/^(\d+\.)?(\d+\.)?(\d+)(-(alpha|beta)\d+)?$/);
        });
      });

      describe('items property', () => {
        beforeEach(async() => {
          group.items = [
            {abbr: 'PM'},
            {name: 'Yuriy Yevstihnyeyev'},
            {abbr: 'SK'},
            {name: 'Jens Jansson'}
          ];
          await nextRender(group);
        });

        it('should render avatar for each item, plus overflow avatar', () => {
          const items = group.shadowRoot.querySelectorAll('vaadin-avatar');
          expect(items.length).to.equal(group.items.length + 1);
        });

        it('should make the overflow avatar hidden by default', () => {
          const items = group.shadowRoot.querySelectorAll('vaadin-avatar');
          const overflow = items[group.items.length];
          expect(overflow.hasAttribute('hidden')).to.be.true;
        });

        it('should propagate theme attribute to all avatars', () => {
          group.setAttribute('theme', 'small');
          const items = group.shadowRoot.querySelectorAll('vaadin-avatar');
          items.forEach(avatar => expect(avatar.getAttribute('theme')).to.equal('small'));
        });
      });

      describe('max property', () => {
        beforeEach(async() => {
          group.items = [
            {abbr: 'PM'},
            {name: 'Yuriy Yevstihnyeyev'},
            {name: 'Serhii Kulykov'},
            {abbr: 'JJ'},
            {}
          ];
          group.max = 2;
          await nextRender(group);
        });

        it('should set abbr property on the overflow avatar', async() => {
          const overflow = group.$.overflow;
          expect(overflow.abbr).to.equal('+3');
        });

        it('should set title attribute on the overflow avatar', async() => {
          const overflow = group.$.overflow;
          const items = group.items;
          expect(overflow.getAttribute('title')).to.equal([items[2].name, items[3].abbr, 'anonymous'].join('\n'));
        });

        it('should show overlay on overflow avatar click', async() => {
          const overflow = group.$.overflow;
          overflow.click();
          expect(overflow.hasAttribute('hidden')).to.be.false;
        });

        it('should render avatar based on max, plus overflow avatar', async() => {
          group.max = 1;
          await nextRender(group);
          const items = group.shadowRoot.querySelectorAll('vaadin-avatar');
          expect(items.length).to.equal(group.max + 1);
        });

        it('should hide overflow avatar when max property is set to null', async() => {
          group.max = 1;
          await nextRender(group);
          group.max = null;
          await nextRender(group);
          expect(group.$.overflow.hasAttribute('hidden')).to.be.true;
        });

        it('should hide overflow avatar when max property is set to undefined', async() => {
          group.max = 1;
          await nextRender(group);
          group.max = undefined;
          await nextRender(group);
          expect(group.$.overflow.hasAttribute('hidden')).to.be.true;
        });

        it('should hide overflow avatar when items property is changed', async() => {
          group.max = 2;
          await nextRender(group);
          group.splice('items', 1, 3);
          await nextRender(group);
          expect(group.$.overflow.hasAttribute('hidden')).to.be.true;
        });
      });

      describe('overlay', () => {
        let overlay, overflow;

        beforeEach(async() => {
          group.items = [
            {abbr: 'PM'},
            {name: 'Yuriy Yevstihnyeyev'},
            {name: 'Serhii Kulykov'},
            {name: 'Jens Jansson'},
          ];
          group.max = 2;
          await nextRender(group);
          overlay = group.$.overlay;
          overflow = group.$.overflow;
        });

        afterEach(() => {
          overlay.close();
        });

        it('should open overlay on overflow avatar click', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            expect(overlay.opened).to.be.true;
            done();
          });
          overflow.click();
        });

        it('should open overlay on overflow avatar Enter', () => {
          MockInteractions.keyDownOn(overflow, 13, [], 'Enter');
          expect(overlay.opened).to.be.true;
        });

        it('should open overlay on overflow avatar Space', () => {
          MockInteractions.keyDownOn(overflow, 32, [], ' ');
          expect(overlay.opened).to.be.true;
        });

        it('should render list-box with items in the overlay', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const list = overlay.content.querySelector('vaadin-avatar-group-list-box');
            expect(list).to.be.ok;
            const items = overlay.content.querySelectorAll('[theme="avatar-group-item"]');
            expect(items.length).to.equal(2);
            done();
          });
          overflow.click();
        });

        it('should render avatar names in the list-box items', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const items = overlay.content.querySelectorAll('[theme="avatar-group-item"]');
            expect(items[0].textContent.trim()).to.equal(group.items[2].name);
            expect(items[1].textContent.trim()).to.equal(group.items[3].name);
            done();
          });
          overflow.click();
        });

        it('should set tabindex="-1" on the avatars in the items', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const avatars = overlay.content.querySelectorAll('vaadin-avatar');
            expect(avatars[0].getAttribute('tabindex')).to.equal('-1');
            expect(avatars[1].getAttribute('tabindex')).to.equal('-1');
            done();
          });
          overflow.click();
        });

        it('should close overlay on subsequent overflow click', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            overflow.click();

            Polymer.RenderStatus.afterNextRender(overlay, () => {
              expect(overlay.opened).to.be.false;
              done();
            });
          });
          overflow.click();
        });

        it('should close overlay on list-box Escape press', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const list = overlay.content.querySelector('vaadin-avatar-group-list-box');
            MockInteractions.keyDownOn(list, 27, [], 'Escape');

            Polymer.RenderStatus.afterNextRender(overlay, () => {
              expect(overlay.opened).to.be.false;
              done();
            });
          });
          overflow.click();
        });

        it('should close overlay on list-box Tab press', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const list = overlay.content.querySelector('vaadin-avatar-group-list-box');
            MockInteractions.keyDownOn(list, 9, [], 'Tab');

            Polymer.RenderStatus.afterNextRender(overlay, () => {
              expect(overlay.opened).to.be.false;
              done();
            });
          });
          overflow.click();
        });

        it('should focus overflow avatar on overlay close', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const spy = sinon.spy(overflow, 'focus');
            overflow.click();

            Polymer.RenderStatus.afterNextRender(overlay, () => {
              expect(spy).to.be.calledOnce;
              done();
            });
          });
          overflow.click();
        });

        it('should restore focus-ring attribute on overlay close', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            overflow.click();

            Polymer.RenderStatus.afterNextRender(overlay, () => {
              expect(overflow.hasAttribute('focus-ring')).to.be.true;
              done();
            });
          });

          overflow.setAttribute('focus-ring', '');
          overflow.click();
        });

        it('should not restore focus-ring attribute on close if not set', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const list = overlay.content.querySelector('vaadin-avatar-group-list-box');
            MockInteractions.keyDownOn(list, 27, [], 'Escape');

            Polymer.RenderStatus.afterNextRender(overlay, () => {
              expect(overflow.hasAttribute('focus-ring')).to.be.false;
              done();
            });
          });

          overflow.click();
        });
      });

      describe('color index', () => {
        let overlay, overflow;

        beforeEach(async() => {
          group.items = [
            {abbr: 'PM', colorIndex: 0},
            {name: 'Yuriy Yevstihnyeyev', colorIndex: 1},
            {name: 'Serhii Kulykov', colorIndex: 2}
          ];
          await nextRender(group);
          overlay = group.$.overlay;
          overflow = group.$.overflow;
        });

        it('should pass color index to avatars', () => {
          const items = group.shadowRoot.querySelectorAll('vaadin-avatar');
          expect(items[0].colorIndex).to.equal(0);
          expect(items[1].colorIndex).to.equal(1);
          expect(items[2].colorIndex).to.equal(2);
        });

        it('should pass color index to overlay avatars', done => {
          group.max = 1;
          overlay.addEventListener('vaadin-overlay-open', () => {
            const avatars = overlay.content.querySelectorAll('vaadin-avatar');
            expect(avatars[0].colorIndex).to.equal(group.items[1].colorIndex);
            expect(avatars[1].colorIndex).to.equal(group.items[2].colorIndex);
            done();
          });
          overflow.click();
        });
      });

      describe('ARIA roles', () => {
        let overlay, overflow;

        beforeEach(async() => {
          group.items = [
            {abbr: 'PM'},
            {name: 'Yuriy Yevstihnyeyev'},
            {name: 'Serhii Kulykov'},
            {name: 'Jens Jansson'},
          ];
          group.max = 2;
          await nextRender(group);
          overlay = group.$.overlay;
          overflow = group.$.overflow;
        });

        afterEach(() => {
          overlay.close();
        });

        it('should set aria-haspopup="listbox" on the overflow avatar', () => {
          expect(overflow.getAttribute('aria-haspopup')).to.equal('listbox');
        });

        it('should set aria-expanded="false" on the overflow avatar', () => {
          expect(overflow.getAttribute('aria-expanded')).to.equal('false');
        });

        it('should set aria-expanded="true" on the overflow avatar on open', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            expect(overflow.getAttribute('aria-expanded')).to.equal('true');
            done();
          });
          overflow.click();
        });

        it('should set role="listbox" on the overlay list-box', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const list = overlay.content.querySelector('vaadin-avatar-group-list-box');
            expect(list.getAttribute('role')).to.equal('listbox');
            done();
          });
          overflow.click();
        });

        it('should set role="option" on the overlay items', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const items = overlay.content.querySelectorAll('[theme="avatar-group-item"]');
            items.forEach(item => {
              expect(item.getAttribute('role')).to.equal('option');
            });
            done();
          });
          overflow.click();
        });

        it('should remove title from the overlay avatars', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const avatars = overlay.content.querySelectorAll('vaadin-avatar');
            avatars.forEach(avatar => {
              expect(avatar.hasAttribute('title')).to.equal(false);
            });
            done();
          });
          overflow.click();
        });

        it('should set aria-hidden="true" on the overlay avatars', done => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            const avatars = overlay.content.querySelectorAll('vaadin-avatar');
            avatars.forEach(avatar => {
              expect(avatar.getAttribute('aria-hidden')).to.equal('true');
            });
            done();
          });
          overflow.click();
        });
      });
    });
  </script>
</body>
